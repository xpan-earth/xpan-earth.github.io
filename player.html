
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>xpan — reproductor</title>
  <style>
    * { box-sizing: border-box; }

    body {
      font-family: 'Times New Roman', serif;
      background: white;
      color: black;
      margin: 0;
      padding: 2rem;
    }

    header {
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 10;
    }

    header img {
      width: 50px;
      height: auto;
    }

    .xpan-audio-block {
      border: 1px solid black;
      padding: 1rem;
      margin-top: 6rem;
      margin-bottom: 3rem;
    }

    .audio-meta .title {
      font-size: 1rem;
      font-weight: bold;
      text-transform: lowercase;
      margin-bottom: 0.2rem;
    }

    .audio-meta .info {
      font-size: 0.85rem;
      opacity: 0.6;
      margin-bottom: 1rem;
    }

    .audio-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .play-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      text-transform: lowercase;
      padding: 0;
    }

    .time-display {
      font-size: 0.85rem;
      min-width: 60px;
    }

    .progress-container {
      position: relative;
      flex-grow: 1;
      height: 2px;
      background: #ddd;
      cursor: pointer;
      touch-action: none;
    }

    .progress-fill {
      height: 2px;
      background: black;
      width: 0%;
    }

    canvas {
      width: 100%;
      height: 100px;
      display: block;
      margin-top: 1rem;
      background: white;
    }

    .soundcloud-embed iframe {
      width: 100%;
      height: 80px;
      border: none;
      margin-top: 1rem;
    }

    @media (max-width: 600px) {
      .audio-controls {
        flex-direction: column;
        align-items: flex-start;
      }

      .progress-container {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <a href="https://xpan.earth">
      <img src="./xpan.svg" alt="xpan">
    </a>
  </header>

  <div class="xpan-audio-block audio-local">
    <div class="audio-meta">
      <div class="title">09.jul.24 — 8:48pm</div>
      <div class="info">archivo .wav con visualizador</div>
    </div>
    <div class="audio-controls">
      <button class="play-button">play</button>
      <div class="time-display">0:00 / 0:00</div>
      <div class="progress-container"><div class="progress-fill"></div></div>
      <audio crossorigin="anonymous">
        <source src="https://s3.amazonaws.com/arena_images-temp/uploads%2F01f4983d-12cc-402a-b61f-b444a0eb7ec3%2F09.jul.24+8.48+pm.wav" type="audio/wav">
      </audio>
    </div>
    <canvas></canvas>
  </div>

  <div class="xpan-audio-block">
    <div class="audio-meta">
      <div class="title">kanedavision — vision_mixtape v2</div>
      <div class="info">soundcloud embed</div>
    </div>
    <div class="soundcloud-embed">
      <iframe scrolling="no" allow="autoplay"
        src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/buy-xpan-model1-now/kanedavision-vision_mixtape-v2-2025&color=%23000000&auto_play=false&hide_related=true&show_comments=false&show_user=false&show_reposts=false&show_teaser=false">
      </iframe>
    </div>
  </div>

<script>
  document.querySelectorAll('.audio-local').forEach((block) => {
    const audio = block.querySelector('audio');
    const button = block.querySelector('.play-button');
    const fill = block.querySelector('.progress-fill');
    const canvas = block.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const timeDisplay = block.querySelector('.time-display');
    const progressContainer = block.querySelector('.progress-container');
    const tooltip = document.createElement('div');

    tooltip.style.position = 'absolute';
    tooltip.style.fontSize = '0.75rem';
    tooltip.style.background = 'white';
    tooltip.style.padding = '0.1rem 0.4rem';
    tooltip.style.border = '1px solid black';
    tooltip.style.pointerEvents = 'none';
    tooltip.style.transform = 'translateX(-50%)';
    tooltip.style.display = 'none';
    block.appendChild(tooltip);

    let audioContext, source, analyser, dataArray, animationId;

    const formatTime = (seconds) => {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    };

    const draw = () => {
      analyser.getByteTimeDomainData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      const sliceWidth = canvas.width / dataArray.length;
      let x = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] / 128.0;
        const y = (v * canvas.height) / 2;
        const vol = Math.abs(v - 1);
        ctx.strokeStyle = `rgb(${100 + vol * 155}, 0, 0)`;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        x += sliceWidth;
      }
      ctx.lineWidth = 1.2;
      ctx.stroke();
      animationId = requestAnimationFrame(draw);
    };

    const setupVisualizer = () => {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      source = audioContext.createMediaElementSource(audio);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      dataArray = new Uint8Array(analyser.fftSize);
      source.connect(analyser);
      analyser.connect(audioContext.destination);
      draw();
    };

    button.addEventListener('click', () => {
      if (audio.paused) {
        audio.play();
        button.innerText = 'pause';
        if (!audioContext) setupVisualizer();
        else animationId = requestAnimationFrame(draw);
      } else {
        audio.pause();
        button.innerText = 'play';
        cancelAnimationFrame(animationId);
      }
    });

    audio.addEventListener('timeupdate', () => {
      fill.style.width = (audio.currentTime / audio.duration) * 100 + '%';
      timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
    });

    audio.addEventListener('ended', () => {
      button.innerText = 'play';
      fill.style.width = '0%';
      cancelAnimationFrame(animationId);
    });

    const seek = (e) => {
      const rect = progressContainer.getBoundingClientRect();
      const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      const percent = Math.max(0, Math.min(1, x / rect.width));
      audio.currentTime = percent * audio.duration;
    };

    const showTooltip = (e) => {
      const rect = progressContainer.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
      const percent = Math.max(0, Math.min(1, x / rect.width));
      const time = percent * audio.duration;
      tooltip.textContent = formatTime(time);
      tooltip.style.left = `${x + rect.left}px`;
      tooltip.style.top = `${rect.top - 25}px`;
      tooltip.style.display = 'block';
    };

    const hideTooltip = () => {
      tooltip.style.display = 'none';
    };

    progressContainer.addEventListener('click', seek);
    progressContainer.addEventListener('touchstart', seek);
    progressContainer.addEventListener('mousemove', showTooltip);
    progressContainer.addEventListener('mouseleave', hideTooltip);

    // Resizing + fullscreen robust handling
    const resizeCanvas = () => {
      cancelAnimationFrame(animationId);
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      if (!audio.paused) animationId = requestAnimationFrame(draw);
    };

    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resizeCanvas, 150);
    });

    resizeCanvas();

    // Fullscreen mode
    canvas.addEventListener('dblclick', () => {
      if (!document.fullscreenElement) {
        canvas.requestFullscreen().catch(err => console.warn(err));
      } else {
        document.exitFullscreen();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'f') {
        if (!document.fullscreenElement) {
          canvas.requestFullscreen().catch(err => console.warn(err));
        } else {
          document.exitFullscreen();
        }
      }
    });
  });
</script>
    

</body>
</html>
